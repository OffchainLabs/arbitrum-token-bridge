name: Add Orbit Chain

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue Number'
        required: true
        type: integer

permissions:
  issues: read
  contents: write
  pull-requests: write

jobs:
  add_orbit_chain:
    runs-on: ubuntu-latest

    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
          
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - run: npm install axios
      - name: Map and store new chain
        id: chain_data
        uses: actions/github-script@v6
        with:
          issue_number: ${{ inputs.issue_number }}
          script: |
            // ========== FETCH ISSUE ==========
            
            github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: core.getInput('issue_number')
            }).then(async response => {
              const issue = response.data
            
              if (issue.state !== 'open') {
                throw `Expected the issue to be open, the current state is ${issue.state}.`
              }

              const fs = require('fs')
            
              const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000'
              const MAINNET_CHAIN_IDS = [1, 42161, 42170]
              const SUPPORTED_IMAGE_EXTENSIONS = ['png', 'svg']
              TODO: Move Orbit chains to json files
              const ORBIT_MAINNETS_PATH = 'packages/arb-token-bridge-ui/src/util/orbitMainnets.json'
              const ORBIT_TESTNETS_PATH = 'packages/arb-token-bridge-ui/src/util/orbitTestnets.json'

              // ========== HELPERS ==========

              function getValueByHeader(header, required = true) {
                // Matches the header and its value; ends at the start of the next header
                const pattern = new RegExp(`###\\s*${header}\\s*[\r\n]+\\s*([\\s\\S]+?)(?=###|$)`, 'g')
                const match = pattern.exec(issue.body)
                const value = match && match[1] ? match[1].trim() : null

                const isUndefined = !value || value === '_No response_'

                if (isUndefined) {
                  if (!required) {
                    // Explicitly return undefined so we do not end up with 'No response' text from the issue
                    return undefined
                  }
                  throw `${header} needs to be defined.`
                }

                return value
              }

              function sanitizeUrl(url) {
                let _url = url

                if (_url.endsWith('/')) {
                  // Remove '/' from the end of the URL
                  _url = _url.slice(0, -1)
                }
              
                if (!_url.startsWith('http')) {
                  return `https://${_url}`
                }
                return _url
              }
              
              // Makes sure every description ends with a dot for consistency
              function sanitizeDescription(description) {  
                if (description.endsWith('.')) {
                  return description
                }
                return description + '.'
              }

              function validateAddress(address) {
                // Could be optional
                if (!address) {
                  return undefined
                }
              
                if (!address.startsWith('0x') || address.length !== 42) {
                  throw `${address} is not a valid address.`
                }
                return address
              }

              function validateColorHex(hex) {
                if (!hex.startsWith('#') || (hex.length !== 4 && hex.length !== 7)) {
                  throw `${hex} is not a valid color hex.`
                }
                return hex
              }

              function stripWhitespace(text) {
                return text.split(' ').join('')
              }

              function nameToSlug(name) {
                return name.toLowerCase().split(' ').join('-')
              }

              // ========== CHAIN DATA ==========

              const chainId = Number(getValueByHeader('Chain ID'))
              const name = getValueByHeader('Chain name')
              const slug = nameToSlug(name)
              const description = sanitizeDescription(getValueByHeader('Chain description'))
              // Do not sanitize URL because it could be an absolute path
              const chainLogo = getValueByHeader('Chain logo')
              const color = validateColorHex(getValueByHeader('Brand color'))
              const rpcUrl = sanitizeUrl(getValueByHeader('RPC URL'))
              const explorerUrl = sanitizeUrl(getValueByHeader('Explorer URL'))
              const parentChainId = Number(getValueByHeader('Parent chain ID'))

              let nativeTokenAddress = validateAddress(getValueByHeader('Native token address', false))
              if (nativeTokenAddress === ADDRESS_ZERO) {
                nativeTokenAddress = undefined
              }
              
              let nativeTokenName = undefined
              let nativeTokenSymbol = undefined
              let nativeTokenLogo = undefined

              // If token address is empty or zero, we take it as ETH.
              // We do not want the input values because issues might have different values set.
              if (nativeTokenAddress) {
                nativeTokenName = getValueByHeader('Native token name')
                nativeTokenSymbol = getValueByHeader('Native token symbol')
                // Do not sanitize URL because it could be an absolute path
                nativeTokenLogo = getValueByHeader('Native token logo')
              }

              const confirmPeriodBlocks = Number(getValueByHeader('confirmPeriodBlocks'))
              const bridge = validateAddress(getValueByHeader('bridge'))
              const inbox = validateAddress(getValueByHeader('inbox'))
              const outbox = validateAddress(getValueByHeader('outbox'))
              const rollup = validateAddress(getValueByHeader('rollup'))
              const sequencerInbox = validateAddress(getValueByHeader('sequencerInbox'))

              const parentCustomGateway = validateAddress(getValueByHeader('Parent customGateway'))
              const parentErc20Gateway = validateAddress(getValueByHeader('Parent ERC20Gateway'))
              const parentGatewayRouter = validateAddress(getValueByHeader('Parent gatewayRouter'))
              const parentMulticall = validateAddress(getValueByHeader('Parent multicall'))
              const parentProxyAdmin = validateAddress(getValueByHeader('Parent proxyAdmin'))
              const parentWeth = validateAddress(getValueByHeader('Parent weth'))
              const parentWethGateway = validateAddress(getValueByHeader('Parent wethGateway'))

              const childCustomGateway = validateAddress(getValueByHeader('Child customGateway'))
              const childErc20Gateway = validateAddress(getValueByHeader('Child ERC20Gateway'))
              const childGatewayRouter = validateAddress(getValueByHeader('Child gatewayRouter'))
              const childMulticall = validateAddress(getValueByHeader('Child multicall'))
              const childProxyAdmin = validateAddress(getValueByHeader('Child proxyAdmin'))
              const childWeth = validateAddress(getValueByHeader('Child weth'))
              const childWethGateway = validateAddress(getValueByHeader('Child wethGateway'))

              // ========== HANDLE IMAGES ==========

              async function tryFetchAndCommitImage(urlOrPath, fileName) {
                if (!urlOrPath.startsWith('http')) {
                  // This is an absolute path and we will use an image that already exists
                  if (!fs.existsSync(urlOrPath)) {
                    throw `Provided absolute path '${urlOrPath}' did not match any existing images.`
                  }
                  return urlOrPath
                }

                // Is not path, we covered it above. Rename for clarity
                const url = urlOrPath

                const axios = require('axios')
                // Make sure we grab just the extension from the URL by stripping query params as well
                const fileExtension = url.split('.').slice(-1)[0].split('?')[0]
                
                if (!SUPPORTED_IMAGE_EXTENSIONS.includes(fileExtension)) {
                  throw `Invalid image extension '${fileExtension}'. Expected one of the following: ${SUPPORTED_IMAGE_EXTENSIONS.join(', ')}.`
                }
                
                // TODO: Create a separate folder for chain logos to keep things tidy
                const imageSavePath = `packages/arb-token-bridge-ui/public/images/${fileName}.${fileExtension}`
                const alreadyExists = fs.existsSync(imageSavePath)

                if (alreadyExists) {
                  console.warn(`${fileName} already exists at path '${imageSavePath}'. Using the existing image.`)
                  return imageSavePath
                }

                const response = await axios({
                  method: 'GET',
                  url,
                  responseType: 'arraybuffer'
                })
    
                const imageBuffer = Buffer.from(response.data, 'binary')
                fs.writeFileSync(imageSavePath, imageBuffer)

                // Commit the new image as it does not exist
                await github.rest.repos.createOrUpdateFileContents({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: imageSavePath,
                  message: 'Add new image',
                  content: imageBuffer.toString('base64'),
                  branch: branchName
                })
              
                return imageSavePath
              }

              // ========== NEW BRANCH AND COMMITS ==========

              // Get the list of all Orbit chains. We need all of them to make some sanity checks
              const testnetOrbitChains = JSON.parse(fs.readFileSync(ORBIT_TESTNETS_PATH, 'utf8'))
              const mainnetOrbitChains = JSON.parse(fs.readFileSync(ORBIT_MAINNETS_PATH, 'utf8'))
              const allOrbitChains = { ...testnetOrbitChains, ...mainnetOrbitChains }
              
              if (allOrbitChains[chainId]) {
                throw `Chain ${chainId} already exists.`
              }

              if (Object.values(allOrbitChains).find(o => o.slug === slug)) {
                throw `Slug ${slug} already exists.`
              }

              const branchName = `add-orbit-chain/${stripWhitespace(name)}`

              // Create a new branch
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/heads/${branchName}`,
                sha: context.sha
              })

              const chainLogoPath = await tryFetchAndCommitImage(chainLogo, `${stripWhitespace(name)}_Logo`)

              let nativeTokenLogoPath = undefined
              if (nativeTokenAddress) {
                nativeTokenLogoPath = chainLogo === nativeTokenLogo
                  // Reuse if the same
                  ? chainLogoPath
                  : tryFetchAndCommitImage(nativeTokenLogo, `${stripWhitespace(name)}_NativeTokenLogo`)
              }
              
              const isMainnet = MAINNET_CHAIN_IDS.includes(parentChainId)
              const orbitListPath = isMainnet ? ORBIT_MAINNETS_PATH : ORBIT_TESTNETS_PATH
              
              // Set variables so they can be used outside this step
              core.setOutput('branch_name', branchName)
              core.setOutput('issue_url', issue.html_url)
              core.setOutput('orbit_list_path', orbitListPath)
              core.setOutput('chain_name', name)

              // ========== ADD CHAIN TO THE ORBIT LIST ==========

              const orbitChain = {
                chainID: chainId,
                confirmPeriodBlocks,
                ethBridge: { bridge, inbox, outbox, rollup, sequencerInbox },
                nativeToken: nativeTokenAddress,
                explorerUrl,
                rpcUrl,
                isArbitrum: true,
                isCustom: true,
                name,
                slug,
                partnerChainID: parentChainId,
                partnerChainIDs: [],
                retryableLifetimeSeconds: 604800,
                tokenBridge: {
                  l1CustomGateway: parentCustomGateway,
                  l1ERC20Gateway: parentErc20Gateway,
                  l1GatewayRouter: parentGatewayRouter,
                  l1MultiCall: parentMulticall,
                  l1ProxyAdmin: parentProxyAdmin,
                  l1Weth: parentWeth,
                  l1WethGateway: parentWethGateway,
                  l2CustomGateway: childCustomGateway,
                  l2ERC20Gateway: childErc20Gateway,
                  l2GatewayRouter: childGatewayRouter,
                  l2Multicall: childMulticall,
                  l2ProxyAdmin: childProxyAdmin,
                  l2Weth: childWeth,
                  l2WethGateway: childWethGateway
                },
                nitroGenesisBlock: 0,
                nitroGenesisL1Block: 0,
                depositTimeout: 1800000,
                blockTime: 0.25,
                bridgeUiConfig: {
                  color,
                  network: {
                    name,
                    logo: chainLogoPath,
                    description
                  },
                  ...(nativeTokenAddress && { nativeTokenData: { 
                   name: nativeTokenName,
                   symbol: nativeTokenSymbol,
                   decimals: 18,
                   logoUrl: nativeTokenLogoPath
                  }})
                }
              }

              // Add the new chain and save
              const orbits = JSON.parse(fs.readFileSync(orbitListPath, 'utf8'))
              orbits[chainId] = orbitChain
              fs.writeFileSync(orbitListPath, JSON.stringify(orbits))
            })

      - run: npm run prettier:format

      - name: Create PR
        uses: actions/github-script@v6
        with:
          script: |
            const issueUrl = '${{ steps.chain_data.outputs.issue_url }}'
            const chainName = '${{ steps.chain_data.outputs.chain_name }}'
            const branchName = '${{ steps.chain_data.outputs.branch_name }}'
            const path = '${{ steps.chain_data.outputs.orbit_list_path }}'
            
            const fs = require('fs')
            const fileContents = fs.readFileSync(path, 'utf8')
            
            const getContentResponse = await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path
            })
            
            await github.rest.repos.createOrUpdateFileContents({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path,
              message: `Update ${path} with new chain`,
              content: Buffer.from(fileContents).toString('base64'),
              sha: getContentResponse.data.sha,
              branch: branchName
            })
              
            // Create pull request
            await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `feat: add Orbit chain - ${chainName}`,
              head: branchName,
              base: 'master',
              body: `Automated pull request to add ${chainName} to the bridge. Closes ${issueUrl}.`
            })

        